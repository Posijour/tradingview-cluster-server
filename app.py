# app.py
import os, time, json, threading, csv, hmac, hashlib
from datetime import datetime, timedelta
from collections import deque, defaultdict
from flask import Flask, request, jsonify
import requests
from collections import deque
from time import monotonic
tg_times = deque(maxlen=20)
import html as _html
def esc(x): return _html.escape(str(x), quote=True)
import re
MD_ESCAPE = re.compile(r'([_*\[\]()~`>#+\-=|{}.!])')
def md_escape(text: str) -> str:
    return MD_ESCAPE.sub(r'\\\1', text)

# =========================
# üîß –ù–ê–°–¢–†–û–ô–ö–ò
# =========================
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "YOUR_TELEGRAM_BOT_TOKEN")
CHAT_ID        = os.getenv("CHAT_ID", "766363011")

# –ö–ª–∞—Å—Ç–µ—Ä—ã
CLUSTER_WINDOW_MIN = int(os.getenv("CLUSTER_WINDOW_MIN", "60"))   # –æ–∫–Ω–æ X –º–∏–Ω
CLUSTER_THRESHOLD  = int(os.getenv("CLUSTER_THRESHOLD", "6"))     # N –º–æ–Ω–µ—Ç
CHECK_INTERVAL_SEC = int(os.getenv("CHECK_INTERVAL_SEC", "60"))   # –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑ –≤ N —Å–µ–∫
VALID_TF = os.getenv("VALID_TF", "15m")
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET", "")                  # ?key=... –¥–ª—è –∑–∞—â–∏—Ç—ã
CLUSTER_COOLDOWN_SEC = int(os.getenv("CLUSTER_COOLDOWN_SEC", "300"))

# Bybit (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
BYBIT_API_KEY    = os.getenv("BYBIT_API_KEY", "")
BYBIT_API_SECRET = os.getenv("BYBIT_API_SECRET", "")
BYBIT_BASE_URL   = os.getenv("BYBIT_BASE_URL", "https://api-testnet.bybit.com")
TRADE_ENABLED    = os.getenv("TRADE_ENABLED", "false").lower() == "true"
MAX_RISK_USDT    = float(os.getenv("MAX_RISK_USDT", "50"))
LEVERAGE         = float(os.getenv("LEVERAGE", "5"))
SYMBOL_WHITELIST = set(s.strip().upper() for s in os.getenv("SYMBOL_WHITELIST","").split(",") if s.strip())

# –õ–æ–≥
LOG_FILE = "signals_log.csv"  # –µ–¥–∏–Ω–æ–µ –∏–º—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–µ–∑–¥–µ

# =========================
# üß† –ì–õ–û–ë–ê–õ–¨–ù–´–ï –°–¢–†–£–ö–¢–£–†–´
signals = deque(maxlen=5000)  # –±—ã–ª–æ –±–µ–∑ maxlen  # —ç–ª–µ–º–µ–Ω—Ç—ã: (epoch_sec, ticker, direction, tf)
lock = threading.Lock()
state_lock = threading.Lock()
last_cluster_sent = {"UP": 0.0, "DOWN": 0.0}
log_lock = threading.Lock()
app = Flask(__name__)
stop_event = threading.Event()

# =========================
# üì© Telegram
# =========================
def send_telegram(text: str):
    if not TELEGRAM_TOKEN or not CHAT_ID:
        print("‚ö†Ô∏è Telegram credentials missing.")
        return
    try:
        safe = md_escape(text)
        now = monotonic()
        tg_times.append(now)
        # –ù–µ —á–∞—â–µ 1 —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Å–µ–∫—É–Ω–¥—É
        if len(tg_times) >= 2 and now - tg_times[-2] < 1.0:
            time.sleep(1.0 - (now - tg_times[-2]))
        # –ò –Ω–µ –±–æ–ª–µ–µ 20 –∑–∞ –º–∏–Ω—É—Ç—É
        if len(tg_times) == tg_times.maxlen and now - tg_times[0] < 60:
            time.sleep(60 - (now - tg_times[0]))
        requests.get(
            f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage",
            params={"chat_id": CHAT_ID, "text": safe, "parse_mode": "MarkdownV2"},
            timeout=8,
        )
        print("‚úÖ Sent to Telegram")
    except Exception as e:
        print("‚ùå Telegram error:", e)

# =========================
# üìù –õ–û–ì–ò–†–û–í–ê–ù–ò–ï
# =========================
def log_signal(ticker, direction, tf, sig_type, entry=None, stop=None, target=None):
    row = [
        datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S"),
        ticker, direction, tf, sig_type,
        entry or "", stop or "", target or ""
    ]
    try:
        with log_lock:
            create_header = not os.path.exists(LOG_FILE)
            with open(LOG_FILE, "a", newline="", encoding="utf-8") as f:
                w = csv.writer(f)
                if create_header:
                    w.writerow(["time_utc","ticker","direction","tf","type","entry","stop","target"])
                w.writerow(row)
                f.flush()
        print(f"üìù Logged {sig_type} {ticker} {direction} {tf}")
    except Exception as e:
        print("‚ùå Log error:", e)

# =========================
# üîê BYBIT HELPERS (v5)
# =========================
def _bybit_sign(payload: dict):
    ts = str(int(time.time() * 1000))
    recv_window = "5000"
    body = json.dumps(payload) if payload else ""
    pre_sign = ts + BYBIT_API_KEY + recv_window + body
    sign = hmac.new(BYBIT_API_SECRET.encode(), pre_sign.encode(), hashlib.sha256).hexdigest()
    headers = {
        "X-BAPI-API-KEY": BYBIT_API_KEY,
        "X-BAPI-SIGN": sign,
        "X-BAPI-TIMESTAMP": ts,
        "X-BAPI-RECV-WINDOW": recv_window,
        "Content-Type": "application/json"
    }
    return headers, body

def bybit_post(path: str, payload: dict) -> dict:
    url = BYBIT_BASE_URL.rstrip("/") + path
    headers, body = _bybit_sign(payload)
    r = requests.post(url, headers=headers, data=body, timeout=10)
    try:
        j = r.json()
    except Exception:
        return {"http": r.status_code, "text": r.text}
    if j.get("retCode", 0) != 0:
        print("‚ùå Bybit error:", j)
    return j

def safe_last_price(symbol: str) -> float:
    try:
        r = requests.get(
            f"{BYBIT_BASE_URL}/v5/market/tickers",
            params={"category": "linear", "symbol": symbol},
            timeout=5
        ).json()
        lst = (((r or {}).get("result") or {}).get("list") or [])
        if not lst:
            return 0.0
        return float(lst[0]["lastPrice"])
    except Exception:
        return 0.0

def set_leverage(symbol: str, leverage: float):
    payload = {"category":"linear", "symbol":symbol, "buyLeverage":str(leverage), "sellLeverage":str(leverage)}
    return bybit_post("/v5/position/set-leverage", payload)

def normalize_qty(symbol: str, qty: float) -> float:
    try:
        r = requests.get(
            f"{BYBIT_BASE_URL}/v5/market/instruments-info",
            params={"category": "linear", "symbol": symbol}, timeout=5
        ).json()
        info = (((r or {}).get("result") or {}).get("list") or [])[0]
        step = float(info.get("lotSizeFilter", {}).get("qtyStep", "0.001"))
        precision = max(0, str(step)[::-1].find('.'))
        normalized = max(step, (qty // step) * step)
        return float(f"{normalized:.{precision}f}")
    except Exception:
        return float(f"{qty:.6f}")

def calc_qty_from_risk(entry: float, stop: float, risk_usdt: float) -> float:
    risk_per_unit = abs(entry - stop)
    if risk_per_unit <= 0:
        return 0.0
    qty = normalize_qty(symbol_or_ticker, qty)
    return float(f"{qty:.6f}")

# === üìà –†–µ–∞–ª—å–Ω—ã–π ATR –∏–∑ —Å–≤–µ—á–µ–π Bybit (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏) ===
def get_atr(symbol: str, period: int = 14, interval: str = "15", limit: int = 100) -> float:
    """
    –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç ATR –ø–æ –ø–æ—Å–ª–µ–¥–Ω–∏–º —Å–≤–µ—á–∞–º Bybit (15m –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é).
    Bybit v5 /v5/market/kline –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–≤–µ—á–∏ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ (–Ω–æ–≤—ã–µ —Å–Ω–∞—á–∞–ª–∞),
    –ø–æ—ç—Ç–æ–º—É —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é.
    """
    try:
        url = f"{BYBIT_BASE_URL}/v5/market/kline"
        params = {"category": "linear", "symbol": symbol, "interval": interval, "limit": limit}
        r = requests.get(url, params=params, timeout=5).json()
        if not isinstance(r, dict) or "result" not in r or not r["result"] or "list" not in r["result"]:
            return 0.0

        candles = r["result"]["list"]  # [ [start, open, high, low, close, volume, ...], ... ]
        if not candles:
            return 0.0

        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (start) –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é
        candles.sort(key=lambda c: int(c[0]))

        highs  = [float(c[2]) for c in candles]
        lows   = [float(c[3]) for c in candles]
        closes = [float(c[4]) for c in candles]

        trs = []
        for i in range(1, len(highs)):
            tr = max(
                highs[i] - lows[i],
                abs(highs[i] - closes[i - 1]),
                abs(lows[i] - closes[i - 1])
            )
            trs.append(tr)

        if not trs:
            return 0.0

        lookback = min(period, len(trs))
        return sum(trs[-lookback:]) / lookback
    except Exception as e:
        print("ATR fetch error:", e)
        return 0.0

def place_order_market_with_tp_sl(symbol: str, side: str, qty: float, tp: float, sl: float):
    payload = {
        "category": "linear",
        "symbol": symbol,
        "side": side,                # "Buy" | "Sell"
        "orderType": "Market",
        "qty": str(qty),
        "timeInForce": "GoodTillCancel",
        "tpSlMode": "Full",
        "takeProfit": str(tp),
        "stopLoss": str(sl),
        "reduceOnly": False
    }
    return bybit_post("/v5/order/create", payload)

# =========================
# üîç –ü–∞—Ä—Å–µ—Ä –≤—Ö–æ–¥—è—â–µ–≥–æ payload
# =========================
def parse_payload(req) -> dict:
    # JSON
    data = request.get_json(silent=True) or {}
    # –µ—Å–ª–∏ –ø—É—Å—Ç–æ ‚Äî –ø—Ä–æ–±—É–µ–º —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å raw
    if not data:
        raw = req.get_data(as_text=True) or ""
        try:
            data = json.loads(raw)
        except:
            data = {}
    return {
        "type": data.get("type", "").upper(),
        "ticker": data.get("ticker", ""),
        "direction": data.get("direction", "").upper(),
        "tf": data.get("tf", "").lower(),
        "message": data.get("message", ""),
        "entry": data.get("entry"),
        "stop": data.get("stop"),
        "target": data.get("target"),
    }

# =========================
# üîî –í–ï–ë–•–£–ö –û–¢ TRADINGVIEW
# =========================
@app.route("/webhook", methods=["POST"])
def webhook():
    if WEBHOOK_SECRET:
        key = request.args.get("key", "")
        if key != WEBHOOK_SECRET:
            return "forbidden", 403

    payload = parse_payload(request)
    typ = payload.get("type", "")
    tf  = payload.get("tf", "")
    msg = payload.get("message", "")

    # 1) MTF —Å–∏–≥–Ω–∞–ª, –ø—Ä–∏—Ö–æ–¥—è—â–∏–π —Å –≥–æ—Ç–æ–≤—ã–º —Ç–µ–∫—Å—Ç–æ–º + (–æ–ø—Ü) —Ü–µ–Ω–∞–º–∏
    if msg:
        send_telegram(msg)
        print(f"üì® Forwarded MTF alert: {payload.get('ticker')} {payload.get('direction')}")

        # –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å/–ª–æ–≥ –¥–ª—è –∫–ª–∞—Å—Ç–µ—Ä–æ–≤ (–µ—Å–ª–∏ TF –ø–æ–¥—Ö–æ–¥–∏—Ç)
        ticker    = payload.get("ticker", "")
        direction = payload.get("direction", "")
        if ticker and direction in ("UP", "DOWN") and tf == VALID_TF:
            now = time.time()
            with lock:
                signals.append((now, ticker, direction, tf))
            log_signal(
                ticker,
                direction,
                tf,
                "MTF",
                payload.get("entry"),
                payload.get("stop"),
                payload.get("target")
            )

        # –ü–æ–ø—ã—Ç–∫–∞ –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª–∏ (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–∞)
        if TRADE_ENABLED and typ == "MTF":
            try:
                symbol    = ticker.upper() if ticker else ""
                direction = direction.upper() if direction else ""

                entry  = float(payload.get("entry") or 0)
                stop   = float(payload.get("stop") or 0)
                target = float(payload.get("target") or 0)

                if not (symbol and direction in ("UP","DOWN")):
                    print("‚õî –ù–µ—Ç symbol/direction ‚Äî –ø—Ä–æ–ø—É—Å–∫ —Ç–æ—Ä–≥–æ–≤–ª–∏")
                elif SYMBOL_WHITELIST and symbol not in SYMBOL_WHITELIST:
                    print(f"‚õî {symbol} –Ω–µ –≤ –±–µ–ª–æ–º —Å–ø–∏—Å–∫–µ ‚Äî –ø—Ä–æ–ø—É—Å–∫")
                elif entry > 0 and stop > 0 and target > 0:
                    side = "Sell" if direction == "UP" else "Buy"  # –∫–æ–Ω—Ç—Ä—Ç—Ä–µ–Ω–¥
                    set_leverage(symbol, LEVERAGE)
                    qty = calc_qty_from_risk(entry, stop, MAX_RISK_USDT)
                    if qty > 0:
                        resp = place_order_market_with_tp_sl(symbol, side, qty, target, stop)
                        print("Bybit order resp:", resp)
                        send_telegram(f"üöÄ *AUTO-TRADE*\n{symbol} {side}\nQty: {qty}\nEntry~{entry}\nTP: {target}\nSL: {stop}")
                else:
                    print("‚ÑπÔ∏è –ù–µ—Ç entry/stop/target ‚Äî –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª—è –ø—Ä–æ–ø—É—â–µ–Ω–∞")
            except Exception as e:
                print("Trade error:", e)

        return jsonify({"status": "forwarded"}), 200

    # 2) –°—Ç–∞—Ä—ã–π/–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç (–±–µ–∑ message), –Ω–æ —Å type/dir/tf
    if typ == "MTF" and tf == VALID_TF:
        ticker    = payload.get("ticker", "")
        direction = payload.get("direction", "")
        if ticker and direction in ("UP", "DOWN"):
            now = time.time()
            with lock:
                signals.append((now, ticker, direction, tf))
            log_signal(
                ticker,
                direction,
                tf,
                "MTF",
                payload.get("entry"),
                payload.get("stop"),
                payload.get("target")
            )

            print(f"‚úÖ {ticker} {direction} ({tf}) added for cluster window")
            return jsonify({"status": "ok"}), 200

    return jsonify({"status": "ignored"}), 200

# üß† –ö–õ–ê–°–¢–ï–†-–í–û–†–ö–ï–†
def cluster_worker():
    while True:
        try:
            try:
                now = time.time()
                cutoff = now - CLUSTER_WINDOW_MIN * 60

                with lock:
                    while signals and signals[0][0] < cutoff:
                        signals.popleft()

                    ups, downs, tickers_seen = set(), set(), set()
                    for (_, t, d, _) in signals:
                        tickers_seen.add(t)
                        if d == "UP":
                            ups.add(t)
                        elif d == "DOWN":
                            downs.add(t)
                    # UP –∫–ª–∞—Å—Ç–µ—Ä
                    with state_lock:
                        if len(ups) >= CLUSTER_THRESHOLD:
                            if now - last_cluster_sent["UP"] >= CLUSTER_COOLDOWN_SEC:
                                msg = (
                                    f"üü¢ *CLUSTER UP* ‚Äî {len(ups)} –∏–∑ {len(tickers_seen)} –º–æ–Ω–µ—Ç "
                                    f"(TF {VALID_TF}, {CLUSTER_WINDOW_MIN} –º–∏–Ω)\n"
                                    f"üìà {', '.join(sorted(list(ups)))}"
                                )
                                send_telegram(msg)
                                log_signal(",".join(sorted(list(ups))), "UP", VALID_TF, "CLUSTER")
                                last_cluster_sent["UP"] = now

                        # DOWN –∫–ª–∞—Å—Ç–µ—Ä
                        with state_lock:
                            if len(downs) >= CLUSTER_THRESHOLD:
                                if now - last_cluster_sent["DOWN"] >= CLUSTER_COOLDOWN_SEC:
                                    msg = (
                                        f"üî¥ *CLUSTER DOWN* ‚Äî {len(downs)} –∏–∑ {len(tickers_seen)} –º–æ–Ω–µ—Ç "
                                        f"(TF {VALID_TF}, {CLUSTER_WINDOW_MIN} –º–∏–Ω)\n"
                                        f"üìâ {', '.join(sorted(list(downs)))}"
                                    )
                                    send_telegram(msg)
                                    log_signal(",".join(sorted(list(downs))), "DOWN", VALID_TF, "CLUSTER")
                                    last_cluster_sent["DOWN"] = now
                        if entry_price <= 0 or atr_val <= 0 or atr_base <= 0:
                            raise ValueError("Bad market/ATR data, skip auto-trade")

                # === üöÄ –ê–í–¢–û–¢–û–†–ì–û–í–õ–Ø –ü–û –ö–õ–ê–°–¢–ï–†–ê–ú (—Å —Ä–µ–∞–ª—å–Ω—ã–º ATR) ===
                if TRADE_ENABLED:
                    try:
                        if len(ups) >= CLUSTER_THRESHOLD and ups:
                            direction = "UP"
                            ticker = list(ups)[0]
                        elif len(downs) >= CLUSTER_THRESHOLD and downs:
                            direction = "DOWN"
                            ticker = list(downs)[0]
                        else:
                            ticker, direction = None, None

                        if ticker and direction:
                            if SYMBOL_WHITELIST and ticker not in SYMBOL_WHITELIST:
                                print(f"‚õî {ticker} –Ω–µ –≤ –±–µ–ª–æ–º —Å–ø–∏—Å–∫–µ ‚Äî –ø—Ä–æ–ø—É—Å–∫ –∫–ª–∞—Å—Ç–µ—Ä–Ω–æ–π —Ç–æ—Ä–≥–æ–≤–ª–∏")
                            else:
                                resp = requests.get(
                                    f"{BYBIT_BASE_URL}/v5/market/tickers",
                                    params={"category": "linear", "symbol": ticker},
                                    timeout=5
                                ).json()
                                entry_price = float(resp["result"]["list"][0]["lastPrice"])

                                atr_val = get_atr(ticker, period=14, interval="15")
                                atr_base = get_atr(ticker, period=100, interval="15")
                                vol_scale = max(0.7, min(atr_val / max(atr_base, 0.0001), 1.3))

                                rr_stop = atr_val * 0.8 * vol_scale
                                rr_target = atr_val * 2.4 * vol_scale

                                stop_price = entry_price + rr_stop if direction == "UP" else entry_price - rr_stop
                                target_price = entry_price - rr_target if direction == "UP" else entry_price + rr_target

                                side = "Sell" if direction == "UP" else "Buy"
                                qty = normalize_qty(symbol, qty)
                                set_leverage(ticker, LEVERAGE)
                                qty = calc_qty_from_risk(entry_price, stop_price, MAX_RISK_USDT)

                                if qty <= 0:
                                    raise ValueError("Qty <= 0 after normalization")
                                if qty > 0:
                                    resp = place_order_market_with_tp_sl(ticker, side, qty, target_price, stop_price)
                                    print(f"üí• Cluster auto-trade {ticker} {side} -> TP:{target_price}, SL:{stop_price}")
                                    send_telegram(
                                        f"‚ö° *CLUSTER AUTO-TRADE*\n{ticker} {side}\nQty: {qty}\n"
                                        f"Entry~{entry_price}\nTP: {target_price}\nSL: {stop_price}"
                                    )
                    except Exception as e:
                        print("‚ùå Cluster auto-trade error:", e)

            except Exception as inner_e:
                print("‚ùå cluster_worker internal error:", inner_e)

            time.sleep(CHECK_INTERVAL_SEC)

        except Exception as outer_e:
            print("üíÄ cluster_worker crashed, restarting in 10s:", outer_e)
            time.sleep(10)

# =========================
# ‚è∞ –ï–ñ–ï–î–ù–ï–í–ù–´–ô HEARTBEAT (03:00 UTC+2)
# =========================
def heartbeat_loop():
    sent_today = None
    while True:
        try:
            now_utc = datetime.utcnow()
            local_time = now_utc + timedelta(hours=2)  # UTC+2
            if local_time.hour == 3 and (sent_today != local_time.date()):
                msg = (
                    f"ü©µ *HEARTBEAT*\n"
                    f"Server alive ‚úÖ\n"
                    f"‚è∞ {local_time.strftime('%H:%M %d-%m-%Y')} UTC+2"
                )
                send_telegram(msg)
                print("üí¨ Heartbeat sent to Telegram.")
                sent_today = local_time.date()
        except Exception as e:
            print("‚ùå Heartbeat error:", e)
        time.sleep(60)

# =========================
# =========================
@app.route("/dashboard")
def dashboard():
    html = [
        "<h2>üìà Active Signals Dashboard</h2>",
        "<table border='1' cellpadding='4'>",
        "<tr><th>Time (UTC)</th><th>Ticker</th><th>Direction</th><th>TF</th><th>Type</th>"
        "<th>Entry</th><th>Stop</th><th>Target</th></tr>"
    ]

    try:
        if not os.path.exists(LOG_FILE):
            html.append("<tr><td colspan='8'>‚ö†Ô∏è No log file found</td></tr>")
        else:
            with log_lock:  # ‚Üê –≤–æ—Ç —Ç—É—Ç –º–∞–≥–∏—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
                with open(LOG_FILE, "r") as f:
                    lines = f.readlines()[-50:]  # –ø–æ—Å–ª–µ–¥–Ω–∏–µ 50 —Å—Ç—Ä–æ–∫, —á—Ç–æ–±—ã –Ω–µ —Ç–æ—Ä–º–æ–∑–∏–ª–æ

            rows = []
            for line in lines:
                parts = [p.strip() for p in line.strip().split(",")]
                # –ø–æ–¥–¥–µ—Ä–∂–∫–∞ —Å—Ç–∞—Ä—ã—Ö –∏ –Ω–æ–≤—ã—Ö –ª–æ–≥–æ–≤
                if len(parts) < 5:
                    continue

                # –∑–∞–ø–æ–ª–Ω—è–µ–º –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –ø–æ–ª—è, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç (–¥–ª—è —Å—Ç–∞—Ä—ã—Ö –ª–æ–≥–æ–≤)
                while len(parts) < 8:
                    parts.append("")

                t, ticker, direction, tf, sig_type, entry, stop, target = parts[:8]

                # –∫—Ä–∞—Å–∏–≤–∞—è –ø–æ–¥—Å–≤–µ—Ç–∫–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π
                color = "#d4ffd4" if direction == "UP" else "#ffd4d4" if direction == "DOWN" else "#f4f4f4"

                row = (
                    f"<tr style='background-color:{color}'>"
                    f"<td>{esc(t)}</td>"
                    f"<td>{esc(ticker)}</td>"
                    f"<td>{esc(direction)}</td>"
                    f"<td>{esc(tf)}</td>"
                    f"<td>{esc(sig_type)}</td>"
                    f"<td>{esc(entry)}</td>"
                    f"<td>{esc(stop)}</td>"
                    f"<td>{esc(target)}</td>"
                    f"</tr>"
                )

                rows.append(row)

            if rows:
                html.extend(reversed(rows))
            else:
                html.append("<tr><td colspan='8'>‚ö†Ô∏è No valid log entries</td></tr>")

    except Exception as e:
        html.append(f"<tr><td colspan='8'>‚ö†Ô∏è Error reading log: {e}</td></tr>")

    html.append("</table>")
    html.append(
        f"<p style='color:gray'>Updated {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}</p>"
    )
    html.append(
        "<p style='font-size:small;color:gray'>Showing last 50 entries from log</p>"
    )
    return "\n".join(html)

# =========================
# =========================
from markupsafe import escape as esc

@app.route("/stats")
def stats():
    if not os.path.exists(LOG_FILE):
        return "<h3>‚ö†Ô∏è –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞</h3>", 200

    try:
        rows = []
        # –∞–∫–∫—É—Ä–∞—Ç–Ω–æ —á–∏—Ç–∞–µ–º –ª–æ–≥ —Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π
        with log_lock:
            with open(LOG_FILE, "r") as f:
                for r in csv.reader(f):
                    if len(r) >= 5:
                        rows.append(r)

        parsed = []
        for r in rows:
            try:
                ts = datetime.strptime(r[0], "%Y-%m-%d %H:%M:%S")
                ticker, direction, tf, typ = r[1], r[2], r[3], r[4]
                entry  = float(r[5]) if len(r) > 5 and r[5] else None
                stop   = float(r[6]) if len(r) > 6 and r[6] else None
                target = float(r[7]) if len(r) > 7 and r[7] else None
                parsed.append((ts, ticker, direction, tf, typ, entry, stop, target))
            except Exception:
                continue

        now = datetime.utcnow()
        last_24h = now - timedelta(hours=24)
        last_7d  = now - timedelta(days=7)

        total = len(parsed)
        total_24h = sum(1 for x in parsed if x[0] >= last_24h)
        mtf = sum(1 for x in parsed if x[4] == "MTF")
        cluster = sum(1 for x in parsed if x[4] == "CLUSTER")
        up_count = sum(1 for x in parsed if x[2] == "UP")
        down_count = sum(1 for x in parsed if x[2] == "DOWN")

        # —Ç–æ—Ä–≥–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        with_prices = [x for x in parsed if x[5] and x[6] and x[7]]
        avg_entry  = sum(x[5] for x in with_prices) / len(with_prices) if with_prices else 0
        avg_stop   = sum(x[6] for x in with_prices) / len(with_prices) if with_prices else 0
        avg_target = sum(x[7] for x in with_prices) / len(with_prices) if with_prices else 0

        # –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–∏–≥–Ω–∞–ª–æ–≤ —Å —Ü–µ–Ω–∞–º–∏
        last_signals = [x for x in with_prices][-10:]
        last_rows_html = "".join(
            f"<tr><td>{esc(x[0].strftime('%Y-%m-%d %H:%M'))}</td>"
            f"<td>{esc(x[1])}</td><td>{esc(x[2])}</td>"
            f"<td>{x[5]}</td><td>{x[6]}</td><td>{x[7]}</td><td>{esc(x[4])}</td></tr>"
            for x in reversed(last_signals)
        )

        # –ø–æ –¥–Ω—è–º/—Ç–∏–ø–∞–º –∑–∞ 7 –¥–Ω–µ–π
        daily = defaultdict(lambda: {"MTF":0, "CLUSTER":0})
        for ts, _, _, _, typ, *_ in parsed:
            if ts >= last_7d:
                key = ts.date().isoformat()
                if typ in ("MTF","CLUSTER"):
                    daily[key][typ] += 1

        daily_html = "".join(
            f"<tr><td>{esc(d)}</td><td>{v['MTF']}</td><td>{v['CLUSTER']}</td></tr>"
            for d, v in sorted(daily.items())
        )

        html = f"""
        <h2>üìä TradingView Signals Stats (7d)</h2>
        <ul>
          <li>–í—Å–µ–≥–æ —Å–∏–≥–Ω–∞–ª–æ–≤: <b>{total}</b></li>
          <li>–ó–∞ 24 —á–∞—Å–∞: <b>{total_24h}</b></li>
          <li>MTF: <b>{mtf}</b> | Cluster: <b>{cluster}</b></li>
          <li>–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ‚Äî üü¢ UP: <b>{up_count}</b> | üî¥ DOWN: <b>{down_count}</b></li>
        </ul>

        <h3>üìà –°—Ä–µ–¥–Ω–∏–µ —Ü–µ–Ω—ã —Å–∏–≥–Ω–∞–ª–æ–≤</h3>
        <ul>
          <li>Entry: <b>{avg_entry:.2f}</b></li>
          <li>Stop: <b>{avg_stop:.2f}</b></li>
          <li>Target: <b>{avg_target:.2f}</b></li>
        </ul>

        <h3>üïí –ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–∏–≥–Ω–∞–ª–æ–≤</h3>
        <table border="1" cellpadding="4">
          <tr><th>–í—Ä–µ–º—è</th><th>–¢–∏–∫–µ—Ä</th><th>–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</th><th>Entry</th><th>Stop</th><th>Target</th><th>–¢–∏–ø</th></tr>
          {last_rows_html if last_rows_html else '<tr><td colspan="7">–ù–µ—Ç —Å–∏–≥–Ω–∞–ª–æ–≤</td></tr>'}
        </table>

        <h4>üìÖ –ü–æ –¥–Ω—è–º (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 7):</h4>
        <table border="1" cellpadding="4">
          <tr><th>–î–∞—Ç–∞ (UTC)</th><th>MTF</th><th>CLUSTER</th></tr>
          {daily_html if daily_html else '<tr><td colspan="3">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</td></tr>'}
        </table>
        <p style='color:gray'>–û–±–Ω–æ–≤–ª–µ–Ω–æ: {esc(now.strftime("%H:%M:%S UTC"))}</p>
        """
        return html
    except Exception as e:
        return f"<h3>‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞: {esc(e)}</h3>", 500

# =========================
@app.route("/simulate", methods=["POST"])
def simulate():
    # –ø—Ä–æ—Å—Ç–∞—è –∑–∞—â–∏—Ç–∞: —Ç–æ—Ç –∂–µ —Å–µ–∫—Ä–µ—Ç –≤ –∑–∞–≥–æ–ª–æ–≤–∫–µ
    if WEBHOOK_SECRET:
        sig = request.headers.get("X-Webhook-Signature", "")
        raw = request.get_data()
        if not verify_signature(WEBHOOK_SECRET, raw, sig):
            return "forbidden", 403
    try:
        data = request.get_json(force=True, silent=True) or {}
        ticker = str(data.get("ticker", "BTCUSDT")).upper()
        direction = str(data.get("direction", "UP")).upper()
        entry = float(data.get("entry", 68000))
        stop = float(data.get("stop", 67500))
        target = float(data.get("target", 69000))
        tf = str(data.get("tf", VALID_TF))

        msg = (
            f"üìä *SIMULATED SIGNAL*\n"
            f"{ticker} {direction} ({tf})\n"
            f"Entry: {entry}\nStop: {stop}\nTarget: {target}\n"
            f"‚è∞ {datetime.utcnow().strftime('%H:%M:%S UTC')}"
        )

        log_signal(ticker, direction, tf, "SIMULATED", entry, stop, target)
        send_telegram(msg)

        print(f"üß™ Simulated signal sent for {ticker} {direction}")
        return jsonify({
            "status": "ok", "ticker": ticker, "direction": direction,
            "entry": entry, "stop": stop, "target": target, "tf": tf
        }), 200
    except Exception as e:
        return jsonify({"status": "error", "error": str(e)}), 500

# =========================
# üîé HEALTH / TEST
# =========================
@app.route("/")
def root():
    return "OK", 200

@app.route("/health")
def health():
    return "OK", 200

@app.route("/test")
def test_ping():
    send_telegram("üß™ Test ping from Render server ‚Äî connection OK.")
    return "Test sent", 200

# app.py (–≤ —Å–∞–º—ã–π –Ω–∏–∑)
if __name__ == "__main__":
    import os
    port = int(os.getenv("PORT", "8080"))
    threading.Thread(target=cluster_worker, daemon=True).start()
    threading.Thread(target=heartbeat_loop, daemon=True).start()
    app.run(host="0.0.0.0", port=port)


